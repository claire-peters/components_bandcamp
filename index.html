<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>D3 Page Template</title>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/topojson-client@3"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://unpkg.com/d3-geo-polygon@1"></script>
<script src="data_prep.js"></script>
<script src="d3_tip.js"></script>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
  <div id="chart-area">
    <form>
        <label><input type="radio" name="circsize" value="1" checked>Equal Size</label>
        <label><input type="radio" name="circsize" value="2">Comparative Size</label>
    </form>
  </div>

<script type="text/javascript">

// SECTION: import data, add related functions

function scenedata(city) {
  var scene = city.artist_cats.slice(0,24)
  // takes in city's scene array and spits out the data needed for the bar chart
  var scene_array = [];
  var num_array = [];
  for (let i = 0; i < scene.length; i++) {
    num_array.push(Math.abs(+scene[i].relative))
    scene_array.push({x: scene[i].genre, y: Math.abs(+scene[i].relative), fill:genreColors(scene[i].genre)})
  }
  return {"scene": scene_array, "num_array": num_array};
};

//SECTION: Set up Assets and styles

const margin = ({top: 20, right: 20, bottom: 30, left: 40})

const genreColors = (genre) => {
  // trying for dynamic color rendering by returning a hex code from the letters of a genre name
  function ascii_to_hexa(str){
    if (str.length < 4) {str = "<".concat(str)}
    if (str.length > 9) {str = str.substring(5,9)}
  	var arr1 = [];
  	for (let n = 0; n < str.length; n ++)
      {
    		var hex = Number(str.charCodeAt(n)).toString(16);
    		arr1.push(hex);
  	  }
      var hexa = arr1.join('');
      var hexastr = hexa.toString();
      return "#".concat(hexastr.substring(1, 7));
    }
  return ascii_to_hexa(genre);
};

const tip = d3.tip()
  .attr('class', "d3-tip")
  .style("color", "white")
  .style("background-color", "black")
  .style("padding", "6px")
  .style("border-radius", "4px")
  .style("font-size", "12px")
  .offset([-10, 0])
  .html(function(d) {return `<div style='float: right'>${d.place}</div>`})

var height = 700;
var width = 900;
var specs = {
  "m_h": height*.7,
  "c_h": height*.6
};

const geooutline = ({type: "Sphere"});
const graticule = d3.geoGraticule10();
// Other projection options: d3.geoMercator(), d3.geoStereographic(), d3.geoEisenlohr()
const projection = d3.geoPolyhedralButterfly()
    .translate([width / 2, (height / 2)-20])
    .precision(.1);

const path = d3.geoPath()
    .projection(projection);

const radius = d3.scaleSqrt()
    .domain([0, d3.max(data, city => city.total_no)])
    .range([1, width / 50]);

data.map((d) => { d.radius = radius(d.total_no); });

const svg = d3.select("body")
    .append("svg")
      .style("width", "900px") //need "px" after the number for Firefox
      .style("height", "700px");


const map = svg.append("g")
    .attr("id", "map");

const mapbg = map.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", width)
    .attr("height", height)
    .attr("mask", "url(#myMask)")
    .attr("fill", "#191A1A");

map.append("path")
    .datum(topojson.feature(theworld, theworld.objects.land))
    // .attr("stroke", "#515150") // removing stroke made biggest difference re: performance issues
    // .attr("stroke-width", .4)
    .attr("fill", "#343332")
    .attr("d", path);

// map.append("path")
//     .attr("d", path(graticule))
//     .attr("id", "graticule")
//     .attr("stroke", "#515150")
//     .attr("stroke-width", 1)
//     .attr("stroke-opacity", "0.3")
//     .attr("fill", "none");
//
// map.append("path")
//     .datum(geooutline)
//     .attr("d", path)
//     .attr("fill", "none")
//     .attr("stroke-width", 1)
//     .attr("stroke", "#515150");

var customshape = `M0,700L233.92640648593908,329.99974719027483L170.64010748464213,293.46137520222373L125.88990164843437,267.6248420400352L81.1396984054818,241.78830015142614L17.853396810929667,205.2499368897957L81.13969840548174,168.71157362816518L125.88990164843432,142.87503173955602L170.64010748464204,117.03849857736752L233.92640648593894,80.50012658931637L233.92669840546478,80.50012658931635L297.21299740676176,117.03849857736746L341.9632032429694,142.87503173955594L386.71340648592206,168.71157362816504L449.9997080804742,205.2499368897955L450.0002919195258,205.2499368897955L513.2865935140779,168.71157362816507L558.0367967570305,142.875031739556L602.7870025932383,117.03849857736748L666.0733015945352,80.50012658931644L666.073593514061,80.50012658931638L729.359892515358,117.03849857736753L774.1100983515656,142.87503173955605L818.8603015945182,168.71157362816524L882.1466031890702,205.24993688979578L818.8603015945182,241.78830015142626L774.1100983515655,267.62484204003533L729.3598925153578,293.46137520222385L666.0735935140608,329.9997471902749L666.0733015945351,330.0002528097252L666.0732927406057,403.0769814503717L666.0733015945351,454.75006311020445L666.073301594535,506.4231468874228L666.073301594535,579.4998734106837L602.786999999983,542.9615101490532L558.0367967570304,517.1249682604441L513.2865997747522,491.2884197627998L450.00029191952575,454.7500631102044L449.9997080804742,454.75006311020445L386.7134002252477,491.2884197627998L341.9632032429695,517.1249682604441L297.2130000000169,542.9615101490532L233.92669840546483,579.4998734106837L233.92669840546483,506.4231468874227L233.9266984054648,454.75006311020445L233.92670725939428,403.0769814503717L233.92669840546478,330.00025280972517L233.9264064859390,329.9997471902748L0.000001,700L900,700L900,0L0,0L0,700Z`

svg.append("path")
    .attr("d", customshape)
    .attr("fill", "#191A1A");

svg.append("path")
    .attr("id", "butterflyborder")
    .datum(geooutline)
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke-width", 1)
    .attr("stroke", "#515150");

svg.append('text')
    .text("Cities With Highest Number of Bandcamp Sales")
    .attr('fill', 'white')
    .attr('class', 'title')
    .attr("font-family", "sans-serif")
    .attr("font-size", "20px")
    .attr('text-anchor', 'middle')
    .attr('x', width/2)
    .attr('y', 20);

const bMargin = 50

// SECTION: setting up chart...


const chart = svg.append("g")
    .attr("transform", `translate(0, ${specs["c_h"]-160}) `);

chart.append("g")
    .attr("stroke-opacity", .9)
    .attr("id", "chartlabel")
    .append('text')
      .text('')
      .attr('fill', 'white')
      .attr('class', 'title')
      .attr('x', width / 2 )
      .attr('y', -100)
      .attr('text-anchor', 'middle');

chart.append("g")
    .attr("id", "x_axis")
    .attr('stroke', 'white');

chart.append("g")
    .attr("id", "y_axis");

chart.append("g")
    .attr("id", "bars");


// Setting up updating functions...

function updateBars(selection, data) {
    let color = genreColors(data.mostpopular);
    let scene = scenedata(data)["scene"];
    let yScale = d3.scaleLinear()
        .domain([0.5, chartmax]).nice()
        .range([specs["c_h"] - bMargin, bMargin]);

    let yAxis = g => g
        .attr("transform", `translate(${bMargin},0)`)
        .call(d3.axisLeft(yScale))
             .attr('stroke', 'white');

    let xScale = d3.scaleBand()
      .domain(d3.range(scene.length))
      .range([bMargin, width - bMargin])
      .padding(0.1);

    let xAxis = g => g
      .attr("transform", `translate(0,${specs["c_h"] - bMargin})`)
      .call(d3.axisBottom(xScale).tickFormat(i => scene[i].x).tickSizeOuter(0));

    selection
        .select("g#bars")
        .selectAll("rect")
        .remove();

    selection
        .select("g#y_axis")
        .call(yAxis);

    selection
        .select("g#x_axis")
        .call(xAxis)
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("transform", `rotate(-40)`);

    selection
        .select("g#chartlabel")
        .select("text")
        .text(data.place);

    selection
        .select("g#bars")
        .selectAll("rect")
        .data(scene)
        .enter()
        .append("rect")
          .attr("fill", color) //(d) => genreColors(d.x)
          .attr("rx", 1)
          .attr("fill-opacity", 0.6)
          .attr("x", (data, i) => xScale(i))
          .attr("y", data => yScale(data.y)) //specs["m_h"] here turns them upside-down, for some reason
          .attr("width", xScale.bandwidth())
          .attr("height", data => yScale(0) - yScale(data.y));
}

map.call(tip);


function drawCircles(selection, n) {
  if (n != "1") {
    selectedCircles.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    circleR = selectedCircles.each(function() {
      d3.select(this)
          .attr("r", d => radius(d.total_no));
    // console.log("this.r", this.r.animVal.valueInSpecifiedUnits)
    });
  }
  else {
    circleR = 5;
    selectedCircles.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    selectedCircles.each(function() {
      d3.select(this)
        .attr("r", 5);
    })
  };
}

const cityCircles = map.append("g")
  .attr("fill-opacity", 0.3);

const selectedCircles = cityCircles.selectAll("circles")
  .attr("id", "cityCircles")
  .data(data)
  .join("circle")
    .attr("transform", (d) => `translate(${projection(d.coords)})`)
    .attr("fill", (d) => genreColors(d.mostpopular))
    //NOTE: mouseover behavior determined here
    .on('mouseenter', function(d) {
      // show tooltip on mouse enter
      var updata = scenedata(d);
      tip.show(d, this);
      chart.call(updateBars, d);
      d3.select(this).attr('fill-opacity', 0.7);
    })
    .on('mouseout', function(d) {
      // hide tooltip on mouse out
      tip.hide();
      d3.select(this).attr('fill-opacity', 0.3)
    });

// SECTION: Load circle toggle
const buttons = d3.selectAll('input');
let buttonvalue = 1;

buttons.on('change', function() {
    cityCircles.call(drawCircles, this.value);
    buttonvalue = d3.select('input[name="circsize"]:checked').node().value;
});

d3.select(window).on("load", function() {
    buttonvalue = d3.select('input[name="circsize"]:checked').node().value;
    cityCircles.call(drawCircles, buttonvalue);

});

function zoomed() {
    map.attr("transform", d3.event.transform);
}

let zoom = map.call(d3.zoom()
    .translateExtent([[10, 80], [890, 585]])
    .extent([[10, 80], [890, 585]])
    .scaleExtent([1, 8])
    .on("zoom", function() {
      const { transform } = d3.event;
      map.attr('transform', transform);
      map.selectAll("circle")
        .attr('r', d => {
          buttonvalue != 1 ? radiusval=d.radius:radiusval=5;
          return radiusval / transform.k;
        });
    })
);

</script>
</body>

</html>
