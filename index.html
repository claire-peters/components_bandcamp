<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>D3 Page Template</title>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/topojson-client@3"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://unpkg.com/d3-geo-polygon@1"></script>
<script src="data_prep.js"></script>
<script src="d3_tip.js"></script>
<link rel="stylesheet" type="text/css" href="style.css" />
<style>
svg.sizeopts {
  color: pink;
  font-family: "sans-serif";
  font-size: 16px;
}
</style>
</head>
<body>
  <div id="chart-area">
    <form>
        <label><input type="radio" name="circsize" class=".sizeopts" value="1" checked>Equal Size</label>
        <label><input type="radio" name="circsize" value="2">Comparative Size</label>
    </form>
  </div>

<script type="text/javascript">

// <form>
//     <label><input type="radio" name="colortheme" value="1" checked>Light</label>
//     <label><input type="radio" name="colortheme" value="2">Dark</label>
// </form>

// SECTION: import data, add related functions

function scenedata(city) {
  var scene = city.artist_cats.slice(0,24)
  // takes in city's scene array and spits out the data needed for the bar chart
  var scene_obj = Object.assign({}, ...scene.map(value => ({[value.genre]: value.relative})));
  console.log("scene_obj", scene_obj);
  return scene_obj;
};

//SECTION: Set up Assets and styles

const margin = ({top: 20, right: 20, bottom: 30, left: 40})

const genreColors = (genre) => {
  // trying for dynamic color rendering by returning a hex code from the letters of a genre name
  function ascii_to_hexa(str){
    if (str.length < 4) {str = "<".concat(str)}
    if (str.length > 9) {str = str.substring(5,9)}
  	var arr1 = [];
  	for (let n = 0; n < str.length; n ++)
      {
    		var hex = Number(str.charCodeAt(n)).toString(16);
    		arr1.push(hex);
  	  }
      var hexa = arr1.join('');
      var hexastr = hexa.toString();
      return "#".concat(hexastr.substring(1, 7));
    }
  return ascii_to_hexa(genre);
};

const tip = d3.tip()
  .attr('class', "d3-tip")
  .style("color", "white")
  .style("background-color", "black")
  .style("padding", "6px")
  .style("border-radius", "4px")
  .style("font-size", "12px")
  .offset([-10, 0])
  .html(function(d) {return `<div style='float: right'>${d.place}</div>`})

var height = 700;
var width = 900;
var specs = {
  "m_h": height*.7,
  "c_h": height*.6
};

const geooutline = ({type: "Sphere"});
// const graticule = d3.geoGraticule10();
const projection = d3.geoPolyhedralButterfly()
    .translate([width / 2, (height / 2)-20])
    .precision(.1);

const path = d3.geoPath()
    .projection(projection);

const radius = d3.scaleSqrt()
    .domain([0, d3.max(data, city => city.total_no)])
    .range([1, width / 50]);

data.map((d) => { d.radius = radius(d.total_no); });

const svg = d3.select("body")
    .append("svg")
      .style("width", "900px") //need "px" after the number for Firefox
      .style("height", "700px");


const map = svg.append("g")
    .attr("id", "map");

const mapbg = map.append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", width)
    .attr("height", height)
    .attr("fill", "black");

map.append("path")
    .datum(topojson.feature(theworld, theworld.objects.land))
    // .attr("stroke", "#515150") // removing stroke made biggest difference re: performance issues
    // .attr("stroke-width", .4)
    .attr("fill", "white")
    .attr("d", path);

// map.append("path")
//     .attr("d", path(graticule))
//     .attr("id", "graticule")
//     .attr("stroke", "#515150")
//     .attr("stroke-width", 1)
//     .attr("stroke-opacity", "0.3")
//     .attr("fill", "none");
//
// map.append("path")
//     .datum(geooutline)
//     .attr("d", path)
//     .attr("fill", "none")
//     .attr("stroke-width", 1)
//     .attr("stroke", "#515150");

var customshape = `M0,700L233.92640648593908,329.99974719027483L170.64010748464213,293.46137520222373L125.88990164843437,267.6248420400352L81.1396984054818,241.78830015142614L17.853396810929667,205.2499368897957L81.13969840548174,168.71157362816518L125.88990164843432,142.87503173955602L170.64010748464204,117.03849857736752L233.92640648593894,80.50012658931637L233.92669840546478,80.50012658931635L297.21299740676176,117.03849857736746L341.9632032429694,142.87503173955594L386.71340648592206,168.71157362816504L449.9997080804742,205.2499368897955L450.0002919195258,205.2499368897955L513.2865935140779,168.71157362816507L558.0367967570305,142.875031739556L602.7870025932383,117.03849857736748L666.0733015945352,80.50012658931644L666.073593514061,80.50012658931638L729.359892515358,117.03849857736753L774.1100983515656,142.87503173955605L818.8603015945182,168.71157362816524L882.1466031890702,205.24993688979578L818.8603015945182,241.78830015142626L774.1100983515655,267.62484204003533L729.3598925153578,293.46137520222385L666.0735935140608,329.9997471902749L666.0733015945351,330.0002528097252L666.0732927406057,403.0769814503717L666.0733015945351,454.75006311020445L666.073301594535,506.4231468874228L666.073301594535,579.4998734106837L602.786999999983,542.9615101490532L558.0367967570304,517.1249682604441L513.2865997747522,491.2884197627998L450.00029191952575,454.7500631102044L449.9997080804742,454.75006311020445L386.7134002252477,491.2884197627998L341.9632032429695,517.1249682604441L297.2130000000169,542.9615101490532L233.92669840546483,579.4998734106837L233.92669840546483,506.4231468874227L233.9266984054648,454.75006311020445L233.92670725939428,403.0769814503717L233.92669840546478,330.00025280972517L233.9264064859390,329.9997471902748L0.000001,700L900,700L900,0L0,0L0,700Z`

svg.append("path")
    .attr("d", customshape)
    .attr("fill", "white");

svg.append("path")
    .attr("id", "butterflyborder")
    .datum(geooutline)
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke-width", 1)
    .attr("stroke", "black");


svg.append('text')
    .text("Equal Size")
    .attr('class', '.sizeopts')
    .attr('x', 20)
    .attr('y', 20);

svg.append('text')
    .text("Comparative Size")
    .attr('class', '.sizeopts')
    .attr('x', 20)
    .attr('y', 40);

const bMargin = 50

// SECTION: setting up chart...


const chart = svg.append("g")
    .attr("transform", `translate(0, ${specs["c_h"]-160}) `);

chart.append("g")
    .attr("stroke-opacity", .9)
    .attr("id", "chartlabel")
    .append('text')
      .text('')
      .attr("font-family", "Open Sans")
      .attr('class', 'title')
      .attr("font-size", "30px")
      .attr('x', width / 2 )
      .attr('y', -185)
      .attr('text-anchor', 'middle');

chart.append("g")
    .attr("id", "y_axis");

let nullset = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

let xScale = d3.scaleBand()
    .domain(d3.range(nullset.length))
    .rangeRound([bMargin, width - bMargin])
    .padding(0.1);

// let xAxis = g => g
//     .call(d3.axisBottom(xScale)
//         .tickFormat(g.i)
//         .tickSizeOuter(0));

let yScale = d3.scaleLinear()
    .domain([0, d3.max(nullset)]).nice()
    .range([600+ bMargin, bMargin]);

chart.append("g")
    .attr("id", "x_axis");
    // .call(xAxis);

chart.append("g")
    .attr("id", "bars")
    .selectAll("rect")
    .data(nullset)
    .enter()
    .append("rect")
      .attr("x", (data, i) => xScale(i))
      .attr("y", data => yScale(data))
      .attr("fill", "blue")
      .attr("rx", 1)
      .attr("fill-opacity", 0.6);


function updateBars(data) {
    let color = genreColors(data.mostpopular);
    let scene = scenedata(data);
    let scenemax = data.artist_cats[0].relative
    let selection = chart

    var t = d3.transition()
        .duration(600)
        .ease(d3.easePolyInOut.exponent(4));

    let yScale = d3.scaleLinear()
        .domain([0, scenemax]).nice()
        .range([specs["c_h"] - bMargin, bMargin]);

    let yAxis = g => g
        .attr("transform", `translate(${bMargin},0)`)
        .transition(t)
        .call(d3.axisLeft(yScale));

     console.log(data)

    let xScale = d3.scaleBand()
      .domain(Object.keys(scene))
      .range([bMargin, width - bMargin])
      .padding(0.1);

    let xAxis = function(g) {
      g.attr("transform", `translate(0,${specs["c_h"] - bMargin})`)
          .call(d3.axisBottom(xScale)
          .tickSizeOuter(0));
    }

    selection
        .select("g#x_axis")
        .attr("transform", `translate(0,${specs["c_h"] - bMargin})`)
        .transition(t).duration(500)
        .call(xAxis)
        .selectAll("text")
            .style("text-anchor", "end")
            .attr("transform", `rotate(-40)`);

    selection
        .select("g#y_axis")
        .call(yAxis);

    selection
        .select("g#chartlabel")
        .select("text")
        .text(data.place);


    let scenearray = [];
    Object.keys(scene).map(key => scenearray.push({x:[key], y:scene[key]}));
    console.log("scenearray", scenearray)

    selection
        .selectAll("rect")
        .data(scenearray)
        .transition() // <---- Here is the transition
        .duration(500) // .5 seconds
        .attr("fill", "red") //(d) => genreColors(d.x)
        .attr("x", data => xScale(data.x))
        .attr("y", data => yScale(data.y)) //specs["m_h"] here turns them upside-down
        .attr("width", xScale.bandwidth())
        .attr("height", data => yScale(0) - yScale(data.y))
        ;
}

map.call(tip);


function drawCircles(selection, n) {
  if (n != "1") {
    selectedShapes.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    circleR = selectedShapes.each(function() {
      d3.select(this)
          .attr("r", d => radius(d.total_no));
    // console.log("this.r", this.r.animVal.valueInSpecifiedUnits)
    });
  }
  else {
    circleR = 5;
    selectedShapes.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    selectedShapes.each(function() {
      d3.select(this)
        .attr("r", 4);
    })
  };
}

function getBoundingBoxCenter (selection) {
  // get the DOM element from a D3 selection
  // you could also use "this" inside .each()
  var element = selection.node();
  // use the native SVG interface to get the bounding box
  var bbox = element.getBBox();
  // return the center of the bounding box
  return [bbox.x + bbox.width/2, bbox.y + bbox.height/2];
}

const cityCircles = map.append("g");
  // .attr("fill-opacity", 0.3);

var cityMask = map.insert('mask', ':first-child')
   .attr('id', 'image_mask');

const selectedShapes = cityCircles.selectAll("circles")
  .attr("id", "cityCircles")
  .data(data)
  .join("circle")
    .attr("transform", (d) => `translate(${projection(d.coords)})`)
    .attr("fill", "black")
    // .attr("fill", (d) => genreColors(d.mostpopular))
    //NOTE: mouseover behavior determined here
    .on('mouseenter', function(d) {
      // show tooltip on mouse enter
      tip.show(d, this);
      d3.select(this).attr('fill', "red");
    })

    // d3.select(button)
        // .on("click", function() {
        // });

    .on('click', function(d) {
      updateBars(d); //Updates the bar chart
    })
    .on('mouseout', function(d) {
      // hide tooltip on mouse out
      tip.hide();
      d3.select(this).attr('fill', "black")
    });

// SECTION: Load circle toggle
const buttons = d3.selectAll('input');
let buttonvalue = 1;

buttons.on('change', function() {
    cityCircles.call(drawCircles, this.value);
    buttonvalue = d3.select('input[name="circsize"]:checked').node().value;
});

d3.select(window).on("load", function() {
    cityCircles.call(drawCircles, buttonvalue);
    buttonvalue = d3.select('input[name="circsize"]:checked').node().value;

});

let zoomed = svg.call(d3.zoom()
    .translateExtent([[17, 100], [883, 580]])
    .extent([[17, 100], [883, 580]])
    .scaleExtent([1, 8])
    .on("zoom", function() {
      const { transform } = d3.event;
      map.attr('transform', transform);
      map.selectAll("circle")
        .attr('r', d => {
          buttonvalue != 1 ? radiusval=d.radius:radiusval=4;
          return radiusval / transform.k;
        });
    })
);

</script>
</body>

</html>
