<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>D3 Page Template</title>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/topojson-client@3"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://unpkg.com/d3-geo-polygon@1"></script>
<script src="data_prep.js"></script>
<script src="d3_tip.js"></script>
<link rel="stylesheet" type="text/css" href="style.css" />
</head>
<body>
  <div id="chart-area">
    <form>
        <label><input type="radio" name="circsize" value="1" checked>Equal Size</label>
        <label><input type="radio" name="circsize" value="2">Comparative Size</label>
    </form>
  </div>

<script type="text/javascript">

// SECTION: import data, add related functions

function scenedata(city) {
  var scene = city.artist_cats.slice(0,24)
  // takes in the city scene array and spits out the information needed for the bar chart
  var scene_array = [];
  var num_array = [];
  for (var i = 0; i < scene.length; i++) {
    num_array.push(Math.abs(+scene[i].relative))
    scene_array.push({x: scene[i].genre, y: Math.abs(+scene[i].relative), fill:genreColors(scene[i].genre)})
  }
  return {"scene": scene_array, "num_array": num_array};
};

//SECTION: Set up Assets and styles

const margin = ({top: 20, right: 20, bottom: 30, left: 40})

const genreColors = (genre) => {
  // trying for dynamic color rendering by returning a hex code from the letters of a genre name
  function ascii_to_hexa(str){
    if (str.length < 4) {str = "<".concat(str)}
    if (str.length > 9) {str = str.substring(5,9)}
  	var arr1 = [];
  	for (var n = 0; n < str.length; n ++)
      {
    		var hex = Number(str.charCodeAt(n)).toString(16);
    		arr1.push(hex);
  	  }
      var hexa = arr1.join('');
      var hexastr = hexa.toString();
      return "#".concat(hexastr.substring(1, 7));
    }
  return ascii_to_hexa(genre);
};

const tip = d3.tip()
  .attr('class', "d3-tip")
  .style("color", "white")
  .style("background-color", "black")
  .style("padding", "6px")
  .style("border-radius", "4px")
  .style("font-size", "12px")
  .offset([-10, 0])
  .html(function(d) {return `<div style='float: right'>${d.place}</div>`})

var height = 700;
var width = 900;
var specs = {
  "m_h": height*.7,
  "c_h": height*.6
};

const geooutline = ({type: "Sphere"});
const graticule = d3.geoGraticule10();
// NOTE: projection type here. Some options: d3.geoMercator(), d3.geoPolyhedralButterfly(), d3.geoStereographic(),
// d3.geoEisenlohr()
const projection = d3.geoPolyhedralButterfly()
    .translate([width / 2, (height / 2)-20])
    .precision(.1);

const path = d3.geoPath()
    .projection(projection);

const radius = d3.scaleSqrt()
    .domain([0, d3.max(data, city => city.total_no)])
    .range([0, width / 50]);

const svg = d3.select("body")
    .append("svg")
      .style("width", "900px") //need "px" after the number for Firefox
      .style("height", "700px");

const mapbg = svg.append("rect")
    .attr("x", -100)
    .attr("y", -100)
    .attr("width", width*1.25)
    .attr("height", height*1.25)
    .attr("fill", "#191A1A");

svg.append('text')
    .text("Cities With Highest Number of Bandcamp Sales")
    .attr('fill', 'white')
    .attr('class', 'title')
    .attr("font-family", "sans-serif")
    .attr("font-size", "20px")
    .attr('text-anchor', 'middle')
    .attr('x', width/2)
    .attr('y', 20);

const map = svg.append("g")
    .attr("id", "map");

map.append("path")
    .datum(topojson.feature(theworld, theworld.objects.land))
    // .attr("stroke", "#515150") // removing stroke did the most to alleviate performance issues
    // .attr("stroke-width", .4)
    .attr("fill", "#343332")
    .attr("d", path);

map.append("path")
    .attr("d", path(graticule))
    .attr("id", "graticule")
    .attr("stroke", "#515150")
    .attr("stroke-width", 1)
    .attr("stroke-opacity", "0.3")
    .attr("fill", "none");

map.append("path")
    .datum(geooutline)
    .attr("d", path)
    .attr("fill", "none")
    .attr("stroke-width", 1)
    .attr("stroke", "#515150");

const bMargin = 50

// SECTION: setting up chart...

const chart = svg.append("g")
    .attr("transform", `translate(0, ${specs["c_h"]-160}) `);

// chart.append("g")
//     .attr("opacity", .9)
//     .append('text')
//       .text('Sales by genre')
//       .attr('fill', 'white')
//       .attr('class', 'title')
//       .attr('x', width / 2 )
//       .attr('y', height*.3)
//       .attr('text-anchor', 'middle');

const charttext = chart.append("g")
    .attr("stroke-opacity", .9)
    .append('text')
      .text('')
      .attr('fill', 'white')
      .attr('class', 'title')
      .attr('x', width / 2 )
      .attr('y', 50)
      .attr('text-anchor', 'middle');

const chartx = chart.append("g")
    .attr("id", "x_axis")
    .attr('stroke', 'white');

const charty = chart.append("g")
    .attr("id", "y_axis");

const chartbars = chart.append("g")
    .attr("id", "bars");



// Setting up updating functions...

function updateBars(selection, data) {
    var color = genreColors(data.mostpopular);
    let scene = scenedata(data)["scene"];
    let yScale = d3.scaleLinear()
        .domain([0.5, chartmax]).nice()
        .range([specs["c_h"] - bMargin, bMargin]);

    let yAxis = g => g
        .attr("transform", `translate(${bMargin},0)`)
        .call(d3.axisLeft(yScale))
             .attr('stroke', 'white');

    let xScale = d3.scaleBand()
      .domain(d3.range(scene.length))
      .range([bMargin, width - bMargin])
      .padding(0.1);

    let xAxis = g => g
      .attr("transform", `translate(0,${specs["c_h"] - bMargin})`)
      .call(d3.axisBottom(xScale).tickFormat(i => scene[i].x).tickSizeOuter(0));

    selection
        .select("g#bars")
        .selectAll("rect")
        .remove();

    selection
        .select("g#y_axis")
        .call(yAxis);

    selection
        .select("g#x_axis")
        .call(xAxis)
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("transform", `rotate(-40)`);

    selection
        .select("g#bars")
        .selectAll("rect")
        .data(scene)
        .enter()
        .append("rect")
          .attr("fill", color) //(d) => genreColors(d.x)
          .attr("rx", 1)
          .attr("fill-opacity", 0.6)
          .attr("x", (data, i) => xScale(i))
          .attr("y", data => yScale(data.y)) //specs["m_h"] here turns them upside-down, for some reason
          .attr("width", xScale.bandwidth())
          .attr("height", data => yScale(0) - yScale(data.y));
}

map.call(tip);

function drawCircles(selection, n) {
  console.log("n (selectedCircles)", n)
  if (n != "1") {
    selectedCircles.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    selectedCircles.each(function() {
      console.log("n != 1")
      d3.select(this)
          .attr("r", d => radius(d.total_no));
    });
  }
  else {
    selectedCircles.each(function() {
      d3.select(this)
      .attr('r', null)
    });
    selectedCircles.each(function() {
      console.log("n = 1")
      d3.select(this)
        .attr("r", 1.1);
    })
  };
}

const cityCircles = map.append("g")
  .attr("fill", "#aa0000")
  .attr("fill-opacity", 0.3);

const selectedCircles = cityCircles.selectAll("circles")
  .attr("id", "cityCircles")
  .data(data)
  .join("circle")
    .attr("transform", (d) => `translate(${projection(d.coords)})`)
    .attr("fill", (d) => genreColors(d.mostpopular))
    //NOTE: mouseover behavior determined here
    .on('mouseenter', function(d) {
      // show tooltip on mouse enter
      var updata = scenedata(d);
      tip.show(d, this);
      chart.call(updateBars, d);
      console.log("this", this, "d", d, "updata", updata);
      d3.select(this).attr('fill-opacity', 0.7);
    })
    .on('mouseout', function(d) {
      // hide tooltip on mouse out
      tip.hide();
      d3.select(this).attr('fill-opacity', 0.3)
    });

// SECTION: Load circle toggle
// ATTN: Right now, it's DOM radio buttons for the sake of adding the function.
// Will sort out the aesthetics later.
const buttons = d3.selectAll('input');

buttons.on('change', function() {
    cityCircles.call(drawCircles, this.value);
});

// ATTN: This would ideally be directly connected to the button checked, but I
// have found no easy way to accomplish this yet.
d3.select(window).on("load", function() {
    cityCircles.call(drawCircles, "1");
});

function zoomed() {
    map.attr("transform", d3.event.transform);
}

map.call(d3.zoom()
    .translateExtent([[0, 0], [width, height]])
    .extent([[0, 0], [width, height]])
    .scaleExtent([1, 8])
    .on("zoom", zoomed));

</script>
</body>
</html>
